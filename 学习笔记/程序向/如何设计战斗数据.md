## 如何设计战斗数据

一个招式对应一个动画，但一个动画中可能有多个攻击点。

故而以攻击点为基本单位，我们设计一个 `AttackPointData`

一个攻击点，大概设计如下：

```c#
public class AttackPointData
{
    public string AnimationName;	// 招式动画名字
    public int AnimationHash;		// 对应的 Hash 值, 可以提供一个编辑器函数一键计算
    
    public float Damage;	// 伤害
    public AttackLevel AttackLevel;	// 攻击等级
    public VFXData[] VFXDatas;		// 该攻击点的玩家特效, 可能有多个
    public VFXData[] EnemyVFXDatas;	// 敌人在受击时的特效, 不同招式受击特效可能不同
    public SFXData SFXData;	// 音效, 大部分情况下都只有 1 个, 不像特效多个那么频繁
}

public enum AttackLevel
{
    LightAttack, NormalAttack, HeavyAttack
}
```

那么对于一个招式，可能是由多个攻击点组成的，因此我们的 `AttackData` 则就是一个 `List<AttackPointData>` 。

那么对于整个连招状态，可能有多个招式，因此 `ComboData` 由是一个 `List<AttackData>`，这里套了 2 层。

那么当玩家执行攻击输入的一瞬间，我们会切换到 `PlayerComboState`，最好能够将状态机与战斗系统进行分离，我们思考一下战斗本质实际上是这个流程：`玩家输入` -> `进行攻击` -> `判定` -> `敌人受击` 。

先不进行分离的话，那就是将逻辑的切换直接写在状态内部，那我们可以先试试，先不要过度设计，看看效果再说：

进入的时候进行一系列初始化，获取到我们的整个 `ComboData`

```c#
public class PlayerComboState : BaseGroundState
{
    private ComboData _data;
    
    // 我们需要一个标号，表示是当前处于哪个招式
    private int _attackIndex;
    
    protected override OnInitialize() {
        // 获取我们配置的数据
        _data = Parent.GetObject<PlayerConfig>().ComboData;
    }
    
    protected override OnEnter() {
        // 进行其他的初始化...
        
        ExecuteCombo(false);
    }
    
    // 我们提供一个标志参数表示当前会不会切换招式
    private void ExecuteCombo(bool IsAddIndex = true) {
        
    }
}
```

