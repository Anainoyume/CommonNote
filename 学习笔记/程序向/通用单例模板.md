**先给出方便复制黏贴的代码，代码的详细解释在最下面**

```C#
public abstract class Singleton<T> : MonoBehaviour where T : Singleton<T>
{
    private static T _instance;
    private static object _lock = new object();

    public static T MainInstance {
        get {
            if (_instance == null) {
                lock (_lock) {
                    _instance = FindObjectOfType<T>() as T; 
                    if (_instance == null) {
                        GameObject go = new GameObject(typeof(T).Name);
                        _instance = go.AddComponent<T>();
                    }
                }
            }
            return _instance;
        }
    }

    
    protected virtual void Awake() {
        if (_instance == null) {
            _instance = (T)this;
            DontDestroyOnLoad(gameObject);
        }
        else {
            Destroy(gameObject);
        }
    }


    private void OnApplicationQuit() {
        _instance = null;
    }
}


//=================================================================================================

public abstract class SingletonNonMono<T> where T : class,new()
{
    private static T _instance;
    private static object _lock = new object();

    public static T MainInstance {
        get {
            if (_instance == null) {
                lock (_lock) {
                    _instance ??= new T();
                }
            }
            return _instance;
        }
    }
    
}

```





---

1. 继承了 MonoBehaviour 的版本，适用于依赖 Unity 全局周期的单例类

```c#
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace GGG.Tool.Singleton
{
    /*
    	Singleton<T> 是一个泛型类, 继承自 MonoBehaviour 表示可以挂载至 GameObject 上
    	where 对 类型T 进行了一个约束: T 必须继承自 Singleton 类。
    	
    	有如下例子解释:
    	我们不能直接继承类似 Singleton<int> 或者 Singleton<string> 这样会发生严重错误
    	虽然我们并不会直接使用 Singleton类, 但是为了类型安全起见, 我们加上这个约束。
    	
    	也就是说如果我们要使用例如 SystemManager 这个类, 我们必须如下书写：
    	
    	public class SystemManager : Singleton<SystemManager>
    	{}
    	
    	这样通过一种类似递归的定义, 我们便限制了 SystemManager 是继承了 Singleton<SystemManager> 的。
    */
    public abstract class Singleton<T> : MonoBehaviour where T : Singleton<T>
    {
        private static T _instance;
        private static object _lock = new object();

        // 这里是代码层面我们的获取
        public static T MainInstance
        {
            get
            {
                if (_instance == null)
                {
                    /* 
                    	这里主要应对在多线程中可能会出现线程冲突同时进入该 if 分支的情况，
                    	我们使用锁来避免重复创建单例
                    */ 
                    lock (_lock)
                    {
                        //先去场景中找有没有这个类
                        _instance = FindObjectOfType<T>() as T; 
                    	/*
                    		如果没有，那么我们自己创建一个 Gameobject ，
                    		然后给他加一个T这个类型的脚本，并赋值给instance
                    	*/
                        if (_instance == null)
                        {
                            GameObject go = new GameObject(typeof(T).Name);
                            _instance = go.AddComponent<T>();
                        }
                    }
                }

                return _instance;
            }
        }
        
		// MonoBehaviour 的 Awake 初始化调用
        // 这里是 Unity 编辑器层面的使用
        protected virtual void Awake()
        {
            // 如果当前 GameObject 所挂载的 Singleton 为空, 我们把这个游戏对象本身赋值进去
            // 因为当前的游戏对象是 "SystemManager"，而 _instance 才是我们要访问的单例
            if (_instance == null)
            {
                _instance = (T)this;
                // 避免切换场景时销毁单例, Unity 在切换场景时会销毁场景内所有的 GameObject
                // 我们的单例类通常都是一些全局配置, 不需要销毁
                DontDestroyOnLoad(gameObject);
            }
            else
            {
                // 如果单例已经存在, 销毁当前单例类, 保证单例的唯一性
                Destroy(gameObject);
            }
        }

		//程序退出时，将instance清空
        private void OnApplicationQuit()
        {
            _instance = null;
        }
    }   
}
```



2. 不继承 MonoBehaviour 的版本，适用于代码内使用的单例类

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace GGG.Tool.Singleton
{
    /*
    	这里对类型 T 的约束为:
    	class - T 必须是一个引用类型
    	new() - T 必须存在一个无参构造函数
    */
    public abstract class SingletonNonMono<T> where T : class, new()
    {
        private static T _instance;
        private static object _lock = new object();

        public static T MainInstance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        // 空合并运算符赋值, 逻辑比较简单不解释了
                        _instance ??= new T();
                    }
                }
                return _instance;
            }
        }
    }

}
```

