# 《来自星尘》摇杆UI动效实现

---

简单说一下思路，就是用SDF画很多个同心圆，然后叠加 sin 波就行了，波可以用一个值来扰动产生涟漪的效果并且使其流动具有方向性 (代码中体现是用了 $uv - center$ 和 $direct$ 的夹角余弦值)。当然直接用 noise 图也行，而且更方便省事还能做出不错的效果。然后就是摇杆往外推的时候并非为胶囊型而是呈一个上窄下宽的胶囊型更为自然。最后注意一下细节就是一开始只有一个圆，随着往外推动的程度同心圆会往外扩散，以及会逐渐出现一个更粗的律动圆环在最内层。实现代码放在下方，代码水平过于菜请大佬轻喷（

```glsl
Shader "MyCustomShader/UVTestShader"
{
    Properties
    {        
        _Center ("Center", Vector) = (0.5,0.5,0,0)        
        _Pointer ("Pointer", Vector) = (0.5, 0.5, 0, 0)
        
        _Radius1_Scale ("R1 调整系数", Float) = 1.0
        _Radius2_Scale ("R2 调整系数", Float) = 1.0
    }
    
    SubShader
    {
        Tags {
            "RenderType" = "Transparent"
            "RenderPipeline" = "UniversalPipeline"
        }

        Pass
        {
            Tags {
                "LightMode" = "UniversalForward"
            }
            
            ZWrite Off
            ZTest Always
            Blend SrcAlpha OneMinusSrcAlpha
            
            HLSLPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float4 _Center;
            float4 _Pointer;

            float _Radius1_Scale;
            float _Radius2_Scale;
            CBUFFER_END
            
            struct Attributes
            {
                float4 vertex : POSITION;
                float2 texcoord : TEXCOORD0;
            };

            struct Varyings
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            float variation(float2 v1, float2 v2, float frequency, float speed, float amplitude)
            {
                float v = dot(normalize(v1), normalize(v2));
	            float waves = sin(v * frequency - _Time.y * speed) / 50.0f +
	                          sin(v * frequency * 3.0 - _Time.y * speed) / 500.0f;
                return amplitude * waves;
            }

            float DrawCircle(float2 uv, float r1, float r2, float remap_len, float frequency, float speed, float amplitude)
            {
                float2 center = _Center.xy;  
                float2 pointer = _Pointer.xy;
                float2 direct = SafeNormalize(float3(_Pointer.xy - _Center.xy, 0.0f)).xy;
                float strength = min(length(pointer - center), 0.5f) * 2.0f;

                float2 remap_pointer = direct * strength * remap_len + center;

                float2 uv_center = uv - center;
                float default_len = length(uv_center);
                float mask_center = step(0, dot(-direct, normalize(uv_center)));

                float2 uv_pointer = uv - remap_pointer;
                float mask_pointer = step(0, dot(direct, normalize(uv_pointer)));
                
                float len = max(
                    length(uv_center) * mask_center +
                    length(uv_pointer) * mask_pointer,
                    abs(uv_center.x * direct.y - uv_center.y * direct.x)
                );

                float2 back_center = center - direct * 0.1f;
                float mask_diff = step(0.0f, dot(-direct, normalize(uv - back_center)));
                float diff = (1.0f - mask_diff) * dot(uv - back_center, direct);
                diff *= diff;
                
                len += variation(
                    uv_center,
                    direct,
                    frequency,
                    speed,
                    amplitude
                ) * diff;
                
                len -= variation(
                    float2(uv_center.y, -uv_center.x),
                    direct,
                    frequency,
                    speed,
                    amplitude
                ) * diff;

                // 让半径外窄内宽
                float dis = dot(uv_center, direct) / (0.2f + (r1 + r2) * 0.5f);
                float r1_fixed = lerp(r1, r1 * _Radius1_Scale, (1.0f - mask_center) * dis * strength);
                float r2_fixed = lerp(r2, r2 * _Radius2_Scale, (1.0f - mask_center) * dis * strength);
                
                len = lerp(
                    step(len, r1_fixed) * step(r2_fixed, len),
                    step(default_len, r1) * step(r2, default_len),
                    step(strength, 0)
                );
                
                return len; 
            }

            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                OUT.pos = TransformObjectToHClip(IN.vertex.xyz);
                OUT.uv = IN.texcoord;
                return OUT;
            }

            float4 frag(Varyings IN) : SV_Target
            {
                float2 uv = IN.uv;

                float len = length(_Pointer.xy - _Center.xy);
                // 防止归一化零向量，除以 0 进行 NaN 污染整个计算
                float2 direct = SafeNormalize(float3(_Pointer.xy - _Center.xy, 0.0f)).xy;
                
                float strength = min(length(_Pointer.xy - _Center.xy), 0.5f) * 2.0f;

                float2 back_center = _Center.xy - direct * 0.22f;
                float mask_diff = step(0.0f, dot(-direct, normalize(uv - back_center)));
                float diff = (1.0f - mask_diff) * dot(uv - back_center, direct);
                diff = (1.0f - diff) * (1.0f - diff);
                diff = lerp(diff, 1.0f, step(strength, 0.0f));

                float s = lerp(0.0f, 10.0f, strength);

                float width = 0.0045;
                float r1 = 0.16f;
                float color = DrawCircle(uv, r1, r1-width, 0.12f, 5.0f, 7.2f, s);
                color += lerp(0.0f, DrawCircle(uv, r1, r1-4*width, 0.10f, 4.0f, 6.8f, s), strength);

                float r2 = lerp(r1, 0.17f, strength);
                color = max(color, DrawCircle(uv, r2, r2-width, 0.14f, 6.5f, 7.8f, s));

                float r3 = lerp(r1, 0.18f, strength);
                color = max(color, DrawCircle(uv, r3, r3-width, 0.16f, 6.5f, 8.4f, s));

                float r4= lerp(r1, 0.19f, strength);
                color = max(color, DrawCircle(uv, r4, r4-width, 0.18f, 7.0f, 9.0f, s));
                
                return float4(color.r * float3(diff, 1.0f, 1.0f), color.r);
            }
            
            ENDHLSL
        }
    }
}
```

