经过投影矩阵将视图空间下的顶点转化到裁剪空间下后，$z$ 和 $w$ 坐标变化如下：
$$
z_{clip} = -z_{view}\frac{Far + Near}{Far - Near} - \frac{2 \cdot Near \cdot Far}{Far - Near}\\
w_{clip} = -z_{view}
$$
 进一步, 需要进行透视除法将裁剪空间下的顶点转化为 归一化设备坐标 (NDC)：
$$
z_{ndc} = \frac{z_{clip}}{w_{clip}} = - \frac{z_{clip}}{z_{view}} = \frac{Far + Near}{Far - Near} + \frac{2 \cdot Near \cdot Far}{(Far - Near) \cdot z_{view}}
$$
由于 $z_{ndc}$ 是 $[-1,1]$ 的，深度贴图会将其映射到 $[0,1]$，因此最后我们在深度贴图采样到的值为：
$$
depth = 0.5 \cdot z_{ndc} + 0.5 
$$

---

现在我们采样到 $depth$ , 这是一个非线性的深度值，我们考虑把他转化为 $z_{view}$ 的线性深度值：

由上式结合可得：
$$
depth = \frac{Far + Near}{2 \cdot (Far - Near)} + \frac{Near \cdot Far}{(Far - Near) \cdot z_{view}} + \frac{1}{2}
$$
反解出 $z_{view}$ 有：
$$
z_{view} = \frac{1}{depth \cdot \frac{Far - Near}{Near \cdot Far} - \frac{1}{Near}}
$$
由于在视图空间中，摄像机正对的 $z$ 轴为负值，因此我们还需要对这个值进行一个取反：
$$
{z_{view}}^{'} = \frac{1}{depth \cdot \frac{Near - Far}{Near \cdot Far} + \frac{1}{Near}} = \frac{\frac{Near \cdot Far}{Near - Far}}{depth + \frac{Far}{Near - Far}}
$$
显然在 $[0,1]$ 存在单调性，且由 $depth$ 取值为 $[0,1]$ 很容易得出，${z_{view}}^{'}$ 的取值为 $[Near, Far]$，我们将其映射到 $[0,1]$。因此我们除以 $Far$，得：
$$
z_{01} = \frac{1}{depth \cdot \frac{Near - Far}{Near} + \frac{Far}{Near}}
$$

> 为什么除以 $Far$ ，这是保证在摄像机能看到的最远的地方显示最亮的颜色。

---

我们如何在代码中，实现这个计算函数？这里需要用内置的 `_ZBufferParams` 变量，他是一个 `float4`。四个分量为如下定义：
$$
\mathrm{zbufferParams.x} = 1 - \frac{Far}{Near} \\
\mathrm{zbufferParams.y} = \frac{Far}{Near} \\
\mathrm{zbufferParams.z} = \frac{1}{Far} - \frac{1}{Near} \\
\mathrm{zbufferParams.w} = \frac{1}{Near}
$$
我们进行如下变形：
$$
z_{01} = \frac{1}{depth \cdot \frac{Near - Far}{Near} + \frac{Far}{Near}} = z_{01} = \frac{1}{depth \cdot (1-\frac{Far}{Near}) + \frac{Far}{Near}}
$$
因此显然，如果我们要得到线性且归一化的深度，可以使用如下代码：

```c++
float z_01 = 1.0f / (_ZBufferParams.x * depth + _ZBufferParams.y);
```

而这正是 Unity 内置函数 `Linear01Depth` 的定义：

```c++
inline float Linear01Depth(float depth) {
    return 1.0f / (_ZBufferParams.x * depth + _ZBufferParams.y);
}
```

顺带一提，Unity 还提供了一个线性深度值但并未将其约束在 $[0,1]$ 值的函数：

```c++
inline float LinearEyeDepth(float depth) {
    return 1.0f / (_ZBufferParams.z * depth + _ZBufferParams.w);
}
```

