```c#
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

public class WizardSmoothNormal : ScriptableWizard
{
    [Label("模型根游戏对象")] public GameObject ModelGameObject;
    
    [MenuItem("GameObject/平滑模型法线")]
    private static void CreateWizard()
    {
        DisplayWizard<WizardSmoothNormal>("法线平滑工具", "计算");
    }

    void OnWizardCreate() {
        // 对所有子物体上的 MeshFilter 应用平滑
        foreach (var item in ModelGameObject.GetComponentsInChildren<MeshFilter>()) {
            SmoothNormals(item.sharedMesh);
        }

        // 对所有子物体上的 SkinnedMeshRenderer 应用平滑
        foreach (var item in ModelGameObject.GetComponentsInChildren<SkinnedMeshRenderer>()) {
            SmoothNormals(item.sharedMesh);
        }
    }

    void OnWizardUpdate() {
        if (ModelGameObject == null) {
            helpString = "请拖入模型根游戏对象！";
            isValid = false;
        }
        else {
            helpString = "确定无误后点击 \"计算\" 按钮开始平滑法线, 可能需要一定时间。";
            isValid = true;
        }
    }
    
    // 核心算法
    private void SmoothNormals(Mesh mesh) {
        Dictionary<Vector3, List<(Vector3, float)>> normalDict = new();
        
        var triangles = mesh.triangles; // 三角形顶点索引
        var vertices = mesh.vertices;   // 顶点数据
        var normals = mesh.normals;     // 法线数据
        var tangents = mesh.tangents;   // 切线数据
        var smoothNormals = mesh.normals; // 初始化为原始法线数组
        
        // 处理每个点上的法线
        for (int i = 0; i <= triangles.Length - 3; i += 3) {
            // 获取一个三角形的三个顶点索引
            int[] triangle = {triangles[i], triangles[i+1], triangles[i+2]};
            
            for (int j = 0; j < 3; j++) {
                int vertexIndex = triangle[j];
                var vertex = vertices[vertexIndex]; // 获取真正的顶点
                
                normalDict.TryAdd(vertex, new List<(Vector3, float)>());

                // 计算从该顶点出发的两条边（构成角度）
                var lineA = (vertices[triangle[(j + 1) % 3]] - vertex).normalized;
                var lineB = (vertices[triangle[(j + 2) % 3]] - vertex).normalized;

                // 缩放线段防止精度丢失（可选）
                lineA *= 10000.0f;
                lineB *= 10000.0f;

                // 计算夹角（用于作为加权平均的权重）
                float angle = Mathf.Acos(
                    Mathf.Clamp(Vector3.Dot(lineA, lineB) / (lineA.magnitude * lineB.magnitude), -1.0f, 1.0f)
                );

                // 计算三角面法线方向（叉积）
                (Vector3, float) normalWeight;
                normalWeight.Item1 = Vector3.Cross(lineA, lineB).normalized;
                normalWeight.Item2 = angle;

                // 加入到该位置的法线列表中
                normalDict[vertex].Add(normalWeight);
            }
        }
        
        // 遍历所有顶点，按位置平均相邻面法线
        for (int i = 0; i < vertices.Length; i++) {
            var vertex = vertices[i];

            // 如果该顶点没有在参与面中出现，则跳过
            if (!normalDict.TryGetValue(vertex, out var currentNormalList)) {
                continue;
            }
            var normalList = currentNormalList;

            // 加权平均法线
            float weightSum = normalList.Sum(tuple => tuple.Item2);
            Vector3 smoothNormal = normalList
                                   .Aggregate(Vector3.zero, (acc, tuple) => acc + tuple.Item1 * (tuple.Item2 / weightSum))
                                   .normalized;
            // 存入数组
            smoothNormals[i] = smoothNormal;
            
            
            // 将法线转换为切线空间（供着色器中使用）
            var normal = normals[i].normalized;
            // 不要直接归一化整个 tangent, 会把 w 的手性也归一化掉
            var tangent = new Vector3(tangents[i].x, tangents[i].y, tangents[i].z);
            tangent.Normalize();
            var binormal = (Vector3.Cross(normal, tangent) * tangents[i].w).normalized;
            
            smoothNormals[i] = new Vector3(
                Vector3.Dot(tangent, smoothNormal),
                Vector3.Dot(binormal, smoothNormal),
                Vector3.Dot(normal, smoothNormal)
            );
        }
        
        // 将最终平滑法线写入 UV7 通道（供 Shader 使用）
        mesh.SetUVs(7, smoothNormals);
    }
}
```

