# 左右值 & 完美转发 & 移动语义

---

## 各种值类型

先说说左右值是个什么东西（以下仅个人理解）：

**左值 : ** 有名字的值, 能被取地址的值。可以出现在赋值号左边, 可以代表某块内存。

**右值 : ** 临时对象, 没有名字, 不能取地址。比如字面量, 运算表达式结果, 函数返回的临时值或返回的右值引用的值, 不可持久化。

**将亡值 : ** 还有这个, 就是一种特殊的右值, 有地址但是快似了。当前是右值, 但也许即将把自己的地址赋值给变量。

---

## 值类型举例

然后说一下，**类型** 和 **值类别**，不是一回事，我这里区分一下。

举几个例子：

```c++
std::string a = "123";

std::string v1 = a;
std::string& v2 = a;
std::string&& v3 = std::string{"123"};
```

这个，v1 的变量类型为普通 std::string 类型, v2 是左值引用类型, v3 是右值引用类型。但是 v1, v2, v3 这三个变量本身作为表达式时的值类别，都是左值，因为它们可以被取到地址。

即用完全的话来说：

>v1 是 普通 std::string 类型的左值变量。
>
>v2 是 左值引用 std::string 类型的左值变量。
>
>v3 是 右值引用 std::string 类型的左值变量。

也就是说呢，这三个值本身都是左值，和他们是什么类型无关。为啥呢？因为 v1, v2, v3 都可以被取到地址，同时它们也全部是 **具名变量** 。任何 **具名变量** 都是可寻址的，都是左值。可以用如下代码实验：

```c++
void print(std::string& s) {
    std::cout << "lvalue: " << s << "\n";
}

void print(std::string&& s) {
    std::cout << "rvalue: " << s << "\n";
}

int main() {
    std::string a = "123";

    std::string v1 = a;
    std::string& v2 = a;
    std::string&& v3 = std::string{"123"};

    print(v1);
    print(v2);
    print(v3);
}
```

输出结果都为：`lvalue 123` ，兄弟们。

所以马上就有一个 **Q1 : **这也太反直觉了，既然值都是左值，那要这个类型有及八用呢？

**A1 : ** 怎么说，一般情况下还真没啥用。因为如果你要调用传入参数为右值的函数，你被保证传入值本身为右值。也就是说上面三种情况，你都必须这样写：

```c++
void print(std::string& s) {
    std::cout << "lvalue: " << s << "\n";
}

void print(std::string&& s) {
    std::cout << "rvalue: " << s << "\n";
}

int main() {
    std::string a = "123";

    std::string   v1 = a;
    std::string&  v2 = a;
    std::string&& v3 = std::string{"123"};

    print(std::move(v1));
    print(std::move(v2));
    print(std::move(v3));
}
```

输出全部为：`rvalue 123`，兄弟们。这里我们先不聊 `std::move` 这个函数本身，我们现在就说从我们不使用模板的情况下，这样区分类型确实没啥用。所以如果直接声明右值引用变量，直接使用它，它的行为和一个普通变量没啥区别，类型信息要用得到，我们就得在用模板的时候才能拿得到类型信息。或者作为函数重载的参数知道重载决议。

---

## std::move 的实现

现在来说说这个 `std::move` 是啥，你也许会说：哇！这也太神奇了，为什么全部变成右值调用了。这个函数是怎么做到的！

然后你去翻它的逻辑，就是全部强行变成右值：

```c++
template<typename _Tp>
_GLIBCXX_NODISCARD
constexpr typename std::remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept { 
    return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); 
}
```

简单说一下，`_GLIBCXX_NODISCARD` 是 GUN 编译器本身提供的宏。它其实就是 C++17 的 `[[nodiscard]]` 。也就是提示你返回值不应该被忽略，那之所以用宏呢就是为了兼容性，这套代码如果在 C++17 标准以下使用，这个 `_GLIBCXX_NODISCARD` 就会被忽略，就不至于代码报错。constexpr 就是经典编译期计算表达式的值，模板元编程就是这样，很多东西都放到编译期来做。

然后来看看具体逻辑：传入的是 `_Tp&& __t` ，太丑了直接简化为 `T&& t` 。那这个 `T&&` 是个啥呢，我们都知道 `T&` 是代表模板类型 `T` 的左值引用类型是不是啊，那这个 `T&&` 是不是模板类型 `T` 的右值引用啊？

其实不是，想不到吧兄弟。这个 `T&&` 是万能引用，是啥呢？也就是你传入左值类型变量，那这里就是左值类型。你传入右值类型变量，这里就是右值。是不是很神奇啊。关于这个模板类型推导马上就说，先看完这个 `std::move` 的实现。然后现在我们是不是传入了一个 `t` 啊，那你会发现这个 `T&&` 其实根本没起到啥作用啊，它唯一作用就是可以接收任何类型的值，因为你看呢我们最后返回的是：

```c++
static_cast<
    typename std::remove_reference<T>::type &&
>(t);
```

这样看更清晰，`remove_reference<T>` 强制移除 `T` 的所有引用，怎么实现的？模板偏特化以及部分匹配规则哈。这里也先不细说。然后直接来一个 `static_cast` 给你强转成带 `&&` 的。所以 `std::move` 这个函数说白了就是抹掉你所有的引用信息，然后强制性把你搞成右值类型。

所以呢这个 `std::move` 函数名其实误导性很强是吧，是不是应该叫 `std::cast_to_rvalue` ，当然这只是随便一说。

---

## 模板类型推导

然后直接来说模板类型推导，首先 C++ 模板类型推导其实就是编译器帮我们猜类型，那么总共呢就会分为四大种。一个一个来说：

#### 1. 传值推导

```c++
template <typename T>
void f(T param);

int x = 27;
const int cx = x;
const int& rx = x;

f(x);  // T 被推导为 int, param 的类型是 int
f(cx); // T 被推导为 int, param 的类型是 int
f(rx); // T 被推导为 int, param 的类型是 int
```

很直观，传值推导会抹掉你的 `cv` 修饰符和引用。`cv` 就是 `const` 和 `volatile`。然后直接给一个值类型出来。为啥抹掉 cv 修饰符呢，因为你都已经按值传递了，值复制一份过去，因此可不可变对原变量也没啥影响，因此抹去。

#### 2. 引用推导

```c++
template <typename T>
void f(T& param);

int x = 27;
const int cx = x;
const int& rx = x;

f(x);  // T 被推导为 int, param 的类型是 int&
f(cx); // T 被推导为 const int, param 的类型是 const int&
f(rx); // T 被推导为 const int, param 的类型是 const int&
```

那么这个引用推导呢，就是一样会消除你的引用信息，但会保留 `cv` 修饰符。然后就是你传右值进去直接给你报错。最后推导出的 param 类型呢就一定是左值引用。引用修改呢，会影响到原来的变量，因此此时 cv 修饰符就要开始发挥作用了。

#### 3. 万能引用推导

```c++
template <typename T>
void f(T&& param);

int x = 27;
const int  cx = x;
const int& rx = x;
int&& y = 23;

foo(x);				// T 为 int&, param 类型为 int&
foo(cx);			// T 为 const int&, param 类型为 const int&
foo(rx);			// T 为 const int&, param 类型为 const int&
foo(23);			// T 为 int, param 类型为 int&&
foo(std::move(y));	 // T 为 int, param 类型为 int&&
```

这个规则很复杂的，主要两条：

**1. ** 如果传入实参类型为左值，那么 T 会被推导为左值引用类型，且保留 cv 修饰符。

**2. ** 如果传入实参类型为右值，那么 T 会被推导为其本身的类型，抹去引用。保留 cv 修饰符。

而最终 param 的类型则会根据引用折叠进行推导，如下：

`T& & -> T&,  T& && -> T&, T&& & -> T&`

`T&& && -> T&&, T && -> T&&`

简单来说就是，叠了一次左值就变左值。只有右值叠右值才会是右值。

#### 4. 指针类型推导

```c++
template <typename T>
void f(T* param) {}

int x = 27;
int* y = &x;
const int* z = &x;
int* const w = &x;

f(&x);		// T 为 int, param 的类型为 int*	
f(y);		// T 为 int, param 的类型为 int*
f(&y);		// T 为 int*, param 的类型为 int**
f(z);		// T 为 const int, param 的类型为 const int*
f(w);		// T 为 int, param 的类型为 int*
```

有趣的一点是，除了万能引用传入左值以外，其他所有情况下。`T` 在进行匹配的时候，都会先忽略其引用性。

接下来我们来玩一玩语言律师，下面有几种特殊推导：

```c++
template <typename T>
void f(T& param) {}

int x = 21;
int* y = &x;

f(&x);	// 错误
f(y);	// 正确, T 为 int*, param 类型为 int* &
```

会不会很懵？但其实第一个错了很简单，对于一个左值变量取地址，是一个表达式运算，它返回一个地址右值，这是一个临时值。它没有被保存在任何变量中。因此右值无法被匹配到左值，故第一个错误。而第二个我们提前存储了其为指针类型，指针类型的左值本身可以被再次取址，因此可以正确匹配为左值引用。

---

## 现代编译器的两大优化

这件事得说三个阶段，在 C++11 很早之前，如果写一个这个函数:

```c++
std::vector<int> create_vector() {
    std::vector vec {1,2,3,4,5};
	return vec;
}

auto v = create_vector();
```

我们来算算帐，`std::vector vec {1,2,3,4,5}` 有参构造一次，`return vec` 拷贝构造一次，`auto v = ...` 拷贝构造一次。

但明明如果我们写 `std::vector v {1,2,3,4,5}` 有参构造一次就行了，多了两次无意义的拷贝构造。当前先不聊移动构造这个东西，先假设现在是古早时期，还没有移动拷贝构造。

#### 1. RVO / NRVO

历史演化就不说了，RVO 就是只要编译器看到你返回值返回了一个临时变量。那么它就会直接在你调用方的地址直接把你函数里返回的那个临时变量构造进去，整个过程只发送一次有参构造。例如：

```c++
std::vector<int> create_vector() {
	return std::vector {1,2,3,4,5};
}

auto v = create_vector();

// 毫无优化
// 1. std::vector {1,2,3,4,5} 有参构造
// 2. 返回值对象 拷贝构造
// 3. v = create_vector 拷贝构造

// 有了 RVO
// 1. std::vector {1,2,3,4,5} 有参构造, 但直接构造在 v 的内存上
// 2. 无了
// 3. 无了
```

也就是说 `RVO` 会直接把后两步给你砍了。那么什么是 `NRVO` 呢？其实就是 `Named RVO` 即具名返回值优化，因为函数内返回值有名字，那可能在函数内对这个变量还会做一些其他的操作，编译器会先去看能不能正确进行这个优化，如果能就会和 `RVO` 行为一样。

值得一提的时候现代编译器上 `RVO` 已经成为一种强制规则了，但 `NRVO` 仍然可以编译时通过参数 `-fno-elide-constructors` 进行关闭。

那么关闭了之后会是什么情况呢？我们举个例子：

```c++
// 关闭 NRVO 优化
std::vector<int> create_vector() {
    std::vector vec {1,2,3,4,5}
	return vec;
}

auto v = create_vector();
```

你会想，我已经关掉了 `NRVO`，这里是不是就是毫无优化了啊。其实又不是，你会发现最后的结果是一次有参构造，一次拷贝构造。为什么？

```c++
// 毫无优化
// 1. std::vector vec {1,2,3,4,5} 有参构造
// 2. 返回值对象 拷贝构造
// 3. v = create_vector() 拷贝构造
```

这里的三步，又是哪步被抹掉了？这里就要引出我们聊的第二个优化了。

#### 2. 强制复制消除 (强制拷贝消除)

现代编译器对于用 **纯右值去初始化一个对象**，将不会调用拷贝，而是直接在声明对象的内存上直接构造一次。这在 C++17 以上是强制规则。

那么回来上面：

```c++
// 关掉了 NRVO, 但哥们我们有强制复制消除
// 1. std::vector vec {1,2,3,4,5} 有参构造   √
// 2. 返回值对象 拷贝构造		            √
// 3. v = create_vector() 拷贝构造           ×  
```

这里返回值拷贝构造以后，编译器会认为你函数返回的是一个`将亡值` 即，即将消亡的。那么此时满足我们强制复制消除的规则，这一块内存会直接构造在 v 上。因此最后 `std::vector vec {1,2,3,4,5}` 有参构造一次，返回时直接构造一次。

---

## 移动语义的真正用处

上面我们说的所有假设，都是基于移动语义还不存在，但实际上移动语义和 RVO/NRVO 还有强制复制消除 等优化是同时发展的。

如果说 `RVO / NRVO` 是我们优化的第一道大关，那么当 `RVO / NRVO` 条件不满足的时候，难道我们真的要调用 拷贝构造 吗？

拷贝构造传入的参数是 `const T&` ，为了保证我们是一个全新的对象，我们必须进行深拷贝。如果这个对象内部还有复杂对象，那就要递归深拷贝下去。这性能消耗想都不用想了。那么如果在我们确定一个值是右值的情况下，也就是这是个临时值。或者说它是将亡值，我们能不能直接把现有的数据全部拿过来用呢？说白了就是在移动拷贝构造里我们直接进行浅拷贝，但是为了安全性以及我们确定被移动的对象之后不会再用了。我们就可以直接把被移动对象设置为空，这样比起深拷贝效率就会高很多。

因此也就是说：

```c++
std::vector<int> vec{1, 2, 3, 4, 5};
std::vector vec2 = std::move(vec);		// 调用移动拷贝构造

for (auto i : vec) {
    std::cout << i << " ";
}
std::cout << std::endl;

for (auto i : vec2) {
    std::cout << i << " ";
}
std::cout << std::endl;
```

最后第一个循环什么也不会输出，第二个则会输出 `1 2 3 4 5`。

也就是说在最上面的例子：

```c++
// 关闭 NRVO 优化
std::vector<int> create_vector() {
    std::vector vec {1,2,3,4,5}	// 有参构造 1 次
	return vec;
}

auto v = create_vector();	// 这里最终会调用一个移动拷贝构造到 v
```

因此移动语义在这种情况下，作为了性能优化的第二大关卡。

---

## 完美转发 (std::forward 的实现)

最后我们才来说一下完美转发，移动语义是强制将任意值包装为右值返回。而完美转发的用武之地是 **还原被具名变量丢失的引用信息**。具体啥意思呢？

```c++
template <typename T>
void warpper(T&& t) {
    // 这里使用的 t 一定是个左值
}
```

完美转发的根本目的就在于，使用传入万能引用保存的引用类型信息，还原我们真正的值类别，并且转发到其他函数调用。如果上面这段代码，无论你传进来左值还是右值，虽然 `T&&` 都可以正常保存其引用信息。但是 `t` 这个变量本身作为一个表达式，作为一个值去使用的时候，它一定是个左值，因为它可以被取址。

我们在开篇就举过这个例子：

```c++ 
int&& x = 13;	// x 的类型是右值引用类型, 但 x 这个值作为表达式使用的时候是左值。
```

而当我们时候完美转发的时候，我们希望它是这样工作的：

```c++
template <typename T>
void foo(T&& t) {
    
    // 我们接受一个万能引用的值时, 如果 t 是左值, 假设具体类型为 Tp, T 会推导为 Tp&
    // 如果 t 是右值, 那么 T 会被推导为 Tp
    
    // 我们希望 forward 接受 t, 那么由于 t 是具名变量, 那么 t 一定得是一个左值
    // 其次, T 为 Tp& 时, 返回 Tp&
    // T 为 Tp 时, 返回 Tp&&
    
    // 且完美转发不能把右值强转为左值, 因为右值是没有变量的
}

// 设计如下函数
 template<typename T>
_GLIBCXX_NODISCARD
constexpr T&&
forward(typename std::remove_reference<T>::type& t) noexcept { 
     return static_cast<T&&>(t); 
}

// 这就完美符合了我们的要求
```

---

## 语言律师环节

最后来玩一玩语言律师环节，我们关掉 `NRVO` ，标准 `C++17` 以上。

```c++
Box foo1(Box x) {
    return x;
}

Box foo2(Box& x) {
    return x;
}

Box foo3(Box& x) {
    return static_cast<Box>(x);
}

Box foo4(Box& x) {
    Box y = static_cast<Box>(x);
    return y;
}


Box a {1};	// 这里的有参构造不考虑

Box b1 {foo1(a)};
// 1. 传参 1 次拷贝构造
// 2. 返回 1 次移动构造

Box b2 {foo2(a)};
// 1. RVO 返回 1 次拷贝构造

Box b3 {foo3(a)};
// 1. RVO 返回 1 次拷贝构造
// 这个值得仔细说说, 下面写出转化图式：
/*
	return static_cast<Box>(x); -> return Box(x); -> 返回临时右值 -> RVO 优化初始化进 b3 地址 ->
	仅调用在 Box(x) 1 次拷贝构造。
*/

Box b4 {foo4(a)};
// 1. 强转 1 次拷贝构造
// 2. 返回 1 次移动构造
```





